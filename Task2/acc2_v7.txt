-- -----------------------------------------------------------------------------
--
--  Title      :  Edge-Detection design project - task 2.
--             :
--  Developers :  YOUR NAME HERE - s??????@student.dtu.dk
--             :  YOUR NAME HERE - s??????@student.dtu.dk
--             :
--  Purpose    :  This design contains an entity for the accelerator that must be build
--             :  in task two of the Edge Detection design project. It contains an
--             :  architecture skeleton for the entity as well.
--             :
--  Revision   :  1.0   ??-??-??     Final version
--             :
--
-- -----------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- The entity for task two. Notice the additional signals for the memory.
-- reset is active high.
--------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.types.all;


entity acc is
    port(
        clk    : in  bit_t;             -- The clock.
        reset  : in  bit_t;             -- The reset signal. Active high.
        addr   : out halfword_t;        -- Address bus for data.
        dataR  : in  word_t;            -- The data bus.
        dataW  : out word_t;            -- The data bus.
        en     : out bit_t;             -- Request signal for data.
        we     : out bit_t;             -- Read/Write signal for data.
        start  : in  bit_t;
        win_ready: in bit_t;
        finish : out bit_t                             
    );
end acc;


--------------------------------------------------------------------------------
-- The architecture of the accelerator
--------------------------------------------------------------------------------
architecture rtl of acc is

    -- All internal signals are defined here  
    subtype pixel_t is std_logic_vector(7 downto 0);
    type row_t is array(0 to 351) of pixel_t;   
    
    constant IMG_HEIGHT  : integer := 288;                -- 0..287
    constant IMG_WIDTH   : integer := 352;
    constant BURST       : integer := 4;
    constant LAST_COL    : integer := IMG_WIDTH - BURST;  -- 348
   
    -- For filing up buffers
    signal LB0, LB1, LB2 : row_t;
    signal col          : integer range 0 to 351 := 0;
    signal row_cnt     : integer range 0 to 287 :=0;
    signal active_buf   : integer range 0 to 2 :=0;    
    -- FLAGS
    signal Data_ready   : std_logic := '0';
    --signal win_ready    : std_logic := '0';
    signal buf_ready    : std_logic :='0';
    signal load_hold    : std_logic :='0';
    
    -- For each pixel in the 3x3 window
    signal p00, p01, p02 : pixel_t;
    signal p10, p11, p12 : pixel_t;
    signal p20, p21, p22 : pixel_t;
    signal sobel_out     : pixel_t;
    
    
    -- NEW SIGNALS -- 
    -- Buffer rotation for row change and new filling of a LBx
    signal rotate_buf   : std_logic := '0';
         
    
begin            
	-----------------------------------------------------
	-- PROCESS
	-- Load from memory
    ----------------------------------------------------
	Load_proc : process(clk)
    begin
        if rising_edge(clk) then
            if reset = '1' then
                col <= 0;
                row_cnt <= 0;
                active_buf <= 0;
                data_ready <= '0';
                buf_ready <= '0';
                load_hold <= '0';
                
                LB0 <= (others => (others => '0'));
                LB1 <= (others => (others => '0'));
                LB2 <= (others => (others => '0'));
            
            else 
                if (win_ready = '1') and (load_hold = '1') then
                    load_hold <= '0';
                end if;
            
                if (row_cnt = IMG_HEIGHT-1) and (buf_ready = '1') and (win_ready = '1') then
                    data_ready <= '1';
                    buf_ready  <= '0';
                end if;             
            
              if (start = '1') AND (load_hold = '0') AND (data_ready = '0') then  
                -- Write 4 pixels to selected buffer
                case active_buf is 
                      when 0 => 
                          LB0(col ) <= dataR(31 downto 24);
                          LB0(col+1) <= dataR(23 downto 16);
                          LB0(col+2) <= dataR(15 downto 8);
                          LB0(col+3) <= dataR(7 downto 0);
                      
                      when 1 =>
                          LB1(col ) <= dataR(31 downto 24);
                          LB1(col+1) <= dataR(23 downto 16);
                          LB1(col+2) <= dataR(15 downto 8);
                          LB1(col+3) <= dataR(7 downto 0);
                      
                      when 2 =>
                          LB2(col ) <= dataR(31 downto 24);
                          LB2(col+1) <= dataR(23 downto 16);
                          LB2(col+2) <= dataR(15 downto 8);
                          LB2(col+3) <= dataR(7 downto 0);
                    when others =>
                        null;
                end case;
                             
                if col < LAST_COL then
                    -- Continue in col                    
                    col <= col + BURST; --col + 4               
                else  
                    col <= 0;                
                if active_buf < 2 then
                    -- Gå til næste buffer (LB0 -> LB1 -> LB2)
                    active_buf <= active_buf + 1; 
                else
                    active_buf <= 0;
                    
                    if buf_ready = '0' then
                       buf_ready <= '1';
                    else
                    
                        if (win_ready = '0') then
                            load_hold <= '1';
                        else
                            load_hold <= '0';
                        end if;
                    
                    end if;
                
                -- Vi må gerne gå til næste række
                if row_cnt < IMG_HEIGHT-1 then
                   row_cnt <= row_cnt + 1;
                end if;
            end if; -- col / LAST_COL
        end if; -- start & load_hold & not data_ready
        end if; -- reset
    end if; -- rising_edge
 end if;
end process Load_proc;

finish <= data_ready;

-----------------------------------------------------------------------------------------------------             
    -------------------------------------------------------
    -- PROCESS 
    -- Rotate buffers when row is done
    -------------------------------------------------------
    rotate_proc : process(clk)
    begin
        if rising_edge(clk) then
            if reset='1' then
                -- Explicit clearing to ensure LB[0:2] is 0 at reset
                LB0 <= (others => (others => '0'));
                LB1 <= (others => (others => '0'));
                LB2 <= (others => (others => '0'));
            elsif rotate_buf = '1' then   -- Flag set from hw_ctrl (FSM)
                LB0 <= LB1;
                LB1 <= LB2;
                -- LB2 is then filled in "LOAD-row" state
            end if;
        end if;
    end process;


    ---------------------------------------------------------------
    -- PROCESS
    -- Extract data from LB[2:0] and place into sobelwindow (3 msb)
    ----------------------------------------------------------------
    create_window : process(LB0, LB1, LB2, col)
    begin
        -- Default-safe for boundary set pixels to 0
        p00 <= (others => '0');  p01 <= (others => '0');  p02 <= (others => '0');
        p10 <= (others => '0');  p11 <= (others => '0');  p12 <= (others => '0');
        p20 <= (others => '0');  p21 <= (others => '0');  p22 <= (others => '0');
    
        -- Only output valid window if col is in valid region
        if col >= 1 and col <= 351 then
            -- row 0
            p00 <= LB0(col-1);
            p01 <= LB0(col);
            p02 <= LB0(col+1);
    
            -- row 1
            p10 <= LB1(col-1);
            p11 <= LB1(col);
            p12 <= LB1(col+1);
    
            -- row 2
            p20 <= LB2(col-1);
            p21 <= LB2(col);
            p22 <= LB2(col+1);
        end if;
    end process;
    
    
    ---------------------------------------------------------------
    -- PROCESS
    -- Extract data from LB[2:0] and place into sobelwindow (3 msb)
    ----------------------------------------------------------------
    word_pack : process(clk)
    begin
        if rising_edge(clk) then
        if reset = '1' then
            sobel_word       <= (others => '0');
            sobel_pix_cnt    <= 0;
            sobel_word_ready <= '0';
        elsif do_sobel = '1' then
            sobel_word_ready <= '0';  -- default hver clk
    
            case sobel_pix_cnt is
                when 0 =>
                    sobel_word( 7 downto  0) <= sobel_out;
                when 1 =>
                    sobel_word(15 downto  8) <= sobel_out;
                when 2 =>
                    sobel_word(23 downto 16) <= sobel_out;
                when others =>  -- 3
                    sobel_word(31 downto 24) <= sobel_out;
            end case;
    
            if sobel_pix_cnt = 3 then
                sobel_pix_cnt    <= 0;
                sobel_word_ready <= '1';  -- nu er 32-bit ord klar til write
            else
                sobel_pix_cnt    <= sobel_pix_cnt + 1;
            end if;
        else
            sobel_word_ready <= '0';
        end if;
    end if;
    end process;

  
   
    ---------------------------------------------------------------
    -- PORT MAPPING 
    -- Sobel_3x3 to acc2
    ----------------------------------------------------------------
    SOBEL_OPS : entity work.sobel_3x3
    port map (
        p00 => p00, p01 => p01, p02 => p02,
        p10 => p10, p11 => p11, p12 => p12,
        p20 => p20, p21 => p21, p22 => p22,
        result_pix => sobel_out
    );

end rtl;
